# Bot commands
@bot.message_handler(commands=['start'])
def start(message):
    bot.reply_to(message, "Welcome! Use /set_pairs to change pairs, /status for current.")

@bot.message_handler(commands=['set_pairs'])
def set_pairs(message):
    user_id = message.from_user.id
    markup = types.InlineKeyboardMarkup()
    btn_regular = types.InlineKeyboardButton("Regular (Crypto/Forex)", callback_data="regular")
    btn_otc = types.InlineKeyboardButton("OTC (Deriv Synthetics)", callback_data="otc")
    markup.add(btn_regular, btn_otc)
    bot.send_message(user_id, "Choose pair type:", reply_markup=markup)

@bot.callback_query_handler(func=lambda call: True)
def callback_query(call):
    user_id = call.from_user.id
    if call.data == "regular":
        user_pairs[user_id] = DEFAULT_PAIRS.copy()
        bot.answer_callback_query(call.id, "Set to regular pairs!")
    elif call.data == "otc":
        user_pairs[user_id] = ['R_10', 'R_25', 'R_50', 'R_75', 'R_100']  # Example Deriv OTC pairs
        bot.answer_callback_query(call.id, "Set to OTC pairs! (Note: Use Deriv API for data)")
    bot.edit_message_text("Pairs updated. Bot will monitor.", call.message.chat.id, call.message.message_id)

@bot.message_handler(commands=['status'])
def status(message):
    user_id = message.from_user.id
    pairs = user_pairs.get(user_id, PAIRS)
    bot.reply_to(message, f"Monitoring: {', '.join(pairs)}\nIntervals: {', '.join(INTERVALS)}")

# Background task for monitoring
async def monitor_pairs():
    while True:
        for pair in PAIRS:  # Or user-specific
            for interval in INTERVALS:
                signal_data = analyze_candles(pair, interval)
                if signal_data:
                    send_signal_message(signal_data)
        await asyncio.sleep(60)  # Check every minute

# For OTC (Deriv), you'd need to integrate Deriv API
# Example stub:
# import websocket  # For Deriv WS
# def fetch_deriv_candles(authorize_token, pair, interval):
#     # Implement WebSocket connection to Deriv API
#     pass
# Then replace exchange.fetch_ohlcv with fetch_deriv_candles in analyze_candles

if name == 'main':
    # Start monitoring task
    loop = asyncio.get_event_loop()
    loop.run_until_complete(monitor_pairs())
    
    # Start bot polling
    bot.polling(none_stop=True)
import websocket
import json

def fetch_deriv_candles(authorize_token, pair, interval, limit=200):
    ws = websocket.WebSocket()
    ws.connect("wss://ws.deriv.com/websockets/v3?app_id=YOUR_APP_ID")
    ws.send(json.dumps({
        "ticks_history": pair,
        "style": "candles",
        "granularity": 60 if interval == '1m' else 300,  # 60s=1m, 300s=5m
        "count": limit,
        "subscribe": 1
    }))
    response = json.loads(ws.recv())
    ws.close()
    # Парси данные в формат [timestamp, open, high, low, close, volume]
    candles = response.get('candles', [])
    return [[c['epoch'] * 1000, c['open'], c['high'], c['low'], c['close'], c['volume']] for c in candles]
API:
8472684949:AAG9Qd7bHt-7BRhNw-7x4nQp3a1Eq2Uoq8k
ID = 978230774
